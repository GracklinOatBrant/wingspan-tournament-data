<html>
<head>
    <meta charset="utf-8">
    <title>Wingspan Tournament Data Visualization</title>
    <link rel="stylesheet" href="assets/chosen.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üê¶</text></svg>">

    <script src="assets/jquery.min.js"></script>
    <script src="assets/chosen.jquery.js"></script>
    <script src="assets/plotly.min.js"></script>
    <style type="text/css">
        label {
            display: inline-block;
        }

        body {
            position: relative;
        }

        .container {
            width: 80%;
            margin: 0 auto;
        }
        
        header {
            padding: 1.5rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        fieldset {
            border: 1px solid #eee;
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 5px;
        }

        fieldset .button {
            vertical-align: middle;
        }

        body::after {
          content: '';
          display: block;
          height: 72px;
        }

        footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            padding: 1.5rem;
            text-align: center;
            background: rgb(250, 250, 250);
            height: 72px;
        }

        .chosen-container,
        .chosen-container .chosen-drop,
        .chosen-container .chosen-choices {
            max-width: 16rem;
        }
    </style>
</head>

<body>
    <header>
        <h1 class="title">ü¶Ö Wingspan Tournament Data Visualization ü¶¢</h1>
    </header>

    <div class='container'>
        <fieldset id="filters" class='filter-fieldset'>
            <label>Tournament:&nbsp;<select data-placeholder="All tournaments" class="tournament-select" multiple></select></label>
            <label>User:&nbsp;<select data-placeholder="All users" class="user-select" multiple></select></label>
            <label>From:&nbsp;<input type='date' class='from-date-input'></label>
            <label>To:&nbsp;<input type='date' class='to-date-input'></label>
            <button class='button is-small clear-filters'>Clear filters</button>
        </fieldset>
        <button class='button is-small is-info' id="add-comparison">
            Add comparison
        </button>

        <div id="scoreHistogram"><center>Loading&hellip;</center><br/></div>
    </div>

   <footer>
    Made by ü¶Ü<a href="https://github.com/GracklinOatBrant/wingspan-tournament-data">GracklinOatBrant</a>üïä &mdash; <a href="https://discord.gg/ryUwcZZYC7">Tournament Discord</a>
   </footer>
</body>

<script>
    const initParams = JSON.parse(new URLSearchParams(location.search).get('search'));
    window.initParams = initParams;

    $(document).ready(async () => {
        const filterHtml = $("#filters").html();

        const todaysDate = new Date().toJSON().slice(0, 10);
        const response = await fetch(`wingspan_tournaments.json?${todaysDate}`);
        const tourneys = await response.json();
        
        // add month name & year to tourneys from date
        for (const tourney of tourneys) {
            const date = tourney.date ? new Date(tourney.date) : new Date();
            tourney.year = date.getFullYear();
            tourney.month = date.toLocaleString('default', { month: 'long' });

            for (const game of tourney.games) {
                game.completed_at = new Date(game.completed_at);
            }
        }

        const userSet = new Set();
        for (const tourney of tourneys) {
            for (const game of tourney.games) {
                for (const user of Object.keys(game.scores)) {
                    userSet.add(user);
                }
            }
        }
        // alphabetize and convert to list
        const users = Array.from(userSet).sort();

        // aggregate tourney info
        const tourneyName = (tourney) => `${tourney.name} (${tourney.month} ${tourney.year})`;
        const tourneyNames = tourneys.map(tourneyName);

        // create a helper class to initialize a fieldset that can contain nested selects
        class FilterFieldset {
            constructor(parentDiv) {
                this.parentDiv = parentDiv;

                this.userSelect = parentDiv.find(".user-select");
                this.tourneySelect = parentDiv.find(".tournament-select");
                this.clearButton = parentDiv.find(".clear-filters");
                this.removeButton = parentDiv.find(".remove-comparison");
                this.fromDateInput = parentDiv.find(".from-date-input");
                this.toDateInput = parentDiv.find(".to-date-input");

                for (const user of users) {
                    this.userSelect.append(`<option value="${user}">${user}</option>`);
                }

                for (const tourney of tourneyNames) {
                    this.tourneySelect.append(`<option value="${tourney}">${tourney}</option>`);
                }

                parentDiv.find('select[multiple]').chosen({
                  case_sensitive_search: false
                });

                this.clearButton.on("click", (ev) => {
                    this.clear();
                    return false;
                });

                if (this.removeButton) {
                    this.removeButton.on("click", (ev) => {
                        this.parentDiv.remove();
                        fieldsets = fieldsets.filter((fieldset) => fieldset !== this);
                        redrawHistogram();
                        return false;
                    });
                }
            }

            inputNames() {
                return ['tourneySelect', 'fromDateInput', 'toDateInput', 'userSelect'];
            }

            getParams() {
                const params = {};

                for (const key of this.inputNames()) {
                  if (this[key].val().length) {
                     params[key] = this[key].val();
                  }
                }

                return params;
            }

            getScores() {
                const allScores = [];

                const userVal = this.userSelect.val();
                const fromVal = this.fromDateInput.val() ? Date.parse(this.fromDateInput.val()) : null;
                const toVal = this.toDateInput.val() ? Date.parse(this.toDateInput.val()) : null;
                const tourneyVal = this.tourneySelect.val();

                for (const tourney of tourneys) {
                    if (tourneyVal.length && !tourneyVal.includes(tourneyName(tourney))) continue;
                    
                    for (const game of tourney.games) {
                        const date = game.completed_at;

                        if (fromVal && !(date >= fromVal)) continue;
                        if (toVal && !(date < toVal)) continue;

                        const scores = game.scores;
                        const users = Object.keys(scores);

                        for (let playerIdx = 0; playerIdx < users.length; playerIdx++) {
                            const user = users[playerIdx];
                            if (userVal.length && !userVal.includes(user)) continue;
                            if (scores[user] == 0) continue;
                            allScores.push(scores[user]);
                        }
                    }
                }

                return allScores;
            }

            clear() {
                this.userSelect.val('').trigger('chosen:updated');
                this.tourneySelect.val('').trigger('chosen:updated');
                this.fromDateInput.val('');
                this.toDateInput.val('');
                if (this.clearCallback) {
                    this.clearCallback();
                }
            }

            on(event, callback) {
                this.userSelect.on(event, callback);
                this.tourneySelect.on(event, callback);
                this.fromDateInput.on(event, callback);
                this.toDateInput.on(event, callback);
                this.clearCallback = callback;
            }

            getLabel() {
                const labelParts = [];
                if (this.tourneySelect.val().length) {
                    labelParts.push(`Tourney: ${this.tourneySelect.val().join(", ")}`);
                }
                if (this.userSelect.val().length) {
                    labelParts.push(`User: ${this.userSelect.val().join(", ")}`);
                }
                if (this.fromDateInput.val()) {
                    labelParts.push(`From ${this.fromDateInput.val()}`);
                }
                if (this.toDateInput.val()) {
                    labelParts.push(`Until ${this.toDateInput.val()}`);
                }
                if (labelParts.length) {
                    return labelParts.join(", ");
                } else {
                    return "All data";
                }
            }
        }

        let redrawHistogram = () => {
            const traces = []
            const params = [];
            fieldsets.forEach((fieldset, i) => {
                const scores = fieldset.getScores();
                const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
                const label = `${fieldset.getLabel()} (Average Score = ${mean.toFixed(2)})`;
                const trace = {
                    x: scores,
                    type: 'histogram',
                    histnorm: 'probability',
                    opacity: 0.5,
                    name: label, 
                    autobinx: false,
                    xbins: {
                        start: 45,
                        end: 160, 
                        size: 5, 
                    }
                };
                traces.push(trace);
                params.push(fieldset.getParams());
            });

            const q = new URLSearchParams(location.search);
            q.set('search', JSON.stringify(params));
            history.replaceState({}, '', `${location.pathname}?${q}`);

            $('#scoreHistogram').html('');

            // Use plotly to draw a histogram of tournament scores
            Plotly.newPlot('scoreHistogram', traces, {
                showlegend: true,
                barmode: "overlay", 
                yaxis: {title: 'Fraction of all scores'},
                legend: {"orientation": "h"},
                title: {
                    text: 'Wingspan Tournament Scores'
                }
            });
        };   

        function debounce(func, timeout = 50) {
          let timer;
          return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => { func.apply(this, args); }, timeout);
          };
        }

        redrawHistogram = debounce(redrawHistogram);

        let fieldsets = [new FilterFieldset($("#filters"))];

        for (const fieldset of fieldsets) {
            fieldset.on("change", redrawHistogram);
        }

        function addFieldset() {
            const newFieldsetEl = $("<fieldset class='filter-fieldset'></fieldset>");
            newFieldsetEl.html(filterHtml);
            newFieldsetEl.append("<button class='button is-small is-warning remove-comparison'>Remove comparison</button>");
            $(".filter-fieldset:last-of-type").after(newFieldsetEl);
            const newFieldset = new FilterFieldset(newFieldsetEl);
            newFieldset.on("change", redrawHistogram);
            fieldsets.push(newFieldset);
            return newFieldset;
        }

        if (initParams.length) {
          for (let key in initParams[0]) {
            fieldsets[0][key].val(initParams[0][key]).trigger('chosen:updated');
          }
          initParams.slice(1).forEach(fieldsetParams => {
            const newFieldset = addFieldset();
            for (let key in fieldsetParams) {
              newFieldset[key].val(fieldsetParams[key]).trigger('chosen:updated');
            }
          });
        }

        $('#add-comparison').on("click", (ev) => {
            addFieldset();
            redrawHistogram();
            return false;
        });

        redrawHistogram();
    });
</script>
</html>
